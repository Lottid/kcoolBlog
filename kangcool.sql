-- phpMyAdmin SQL Dump
-- version 4.0.10deb1
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2014-11-03 23:21:38
-- 服务器版本: 5.5.40-0ubuntu0.14.04.1
-- PHP 版本: 5.5.9-1ubuntu4.5

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `kangcool`
--

-- --------------------------------------------------------

--
-- 表的结构 `k_blogs`
--

CREATE TABLE IF NOT EXISTS `k_blogs` (
  `kt_blogs_ids` int(20) NOT NULL AUTO_INCREMENT,
  `kt_blogs_dates` datetime DEFAULT NULL,
  `kt_blogs_contents` text,
  `kt_blogs_titles` varchar(100) DEFAULT NULL,
  `stochastic_figure` text,
  `kt_tags_ids` int(20) DEFAULT NULL,
  `kt_blogs_year` varchar(50) DEFAULT NULL,
  `kt_blogs_yue` varchar(50) DEFAULT NULL,
  `kt_blogs_ri` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`kt_blogs_ids`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=63 ;

--
-- 转存表中的数据 `k_blogs`
--

INSERT INTO `k_blogs` (`kt_blogs_ids`, `kt_blogs_dates`, `kt_blogs_contents`, `kt_blogs_titles`, `stochastic_figure`, `kt_tags_ids`, `kt_blogs_year`, `kt_blogs_yue`, `kt_blogs_ri`) VALUES
(50, '2014-10-21 08:40:36', '<p>１、什么是FOUC？你如何来避免FOUC</p>\n\n<blockquote>\n<p>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：</p>\n\n<ul>\n	<li>使用import方法导入样式表</li>\n	<li>将样式表放在页面底部</li>\n	<li>有几个样式表，放在html结构的不同位置，其实原理很清楚：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染，此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象</li>\n</ul>\n\n<p>解决方法：使用LINK标签将样式表放在文档HEAD中更多</p>\n</blockquote>\n\n<p>&nbsp;<em>２、对网页标准和标准制定机构重要性&nbsp;</em></p>\n\n<blockquote>\n<p>w3c存在的意义就是让浏览器兼容性问题尽量小，首先是他们对浏览器开发者的约束，然后是对开发者的约束</p>\n</blockquote>\n\n<p>３、减低页面加载时间的方法</p>\n\n<blockquote>\n<ul>\n	<li>\n	<p>减少页面HTTP请求数量</p>\n	</li>\n	<li>\n	<p>使用CDN(Content Delivery Network)网络加速<br />\n	现在国内做CDN加速业务的公司很多，简单讲，就是将你的图片、视频扩散到CDN网络所能到达之处，让用户访问时能就近下载到这些文件，从而达到网络提速的目的，这样做，同时能减轻你自己网站的负载。</p>\n	</li>\n	<li>添加文件过期或缓存头 对于同一用户频繁访问的图片、Js脚本文件等可以在Apache或Nginx设置其缓冲 时间，例如设置24小时过期时间，这样用户在访问过该页面之后再次访问时，同一组图片或JS不会再重复下载，从而减少了HTTP请求，用户访问速度明显有 所提升，同时服务器负载也会下降。下面给出nginx配置中缓存控制的例子：\n	<pre class="linenums" id="prettyprint">\nlocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$   \n{   \nexpires 30d;#设置30天过期  \n}  \nlocation ~ .*\\.(js|css)?$   \n{  \nexpires 1h;#设置1小时过期  \n} </pre>\n	</li>\n	<li>\n	<p>服务器开启gzip压缩</p>\n\n	<p>这个大家都比较了解，即将需要传输的内容压缩后传输到客户端再解压，这样在网络上传输的 数据量会大幅减小。通常在服务器上的Apache、Nginx可以直接开启这个设置，也可以从代码角度直接设置传输文件头，增加gzip的设置，也可以从 负载均衡设备直接设置。不过需要留意的是，这个设置会略微增加服务器的负担。</p>\n	</li>\n	<li>\n	<p>css格式定义放置在文件头部</p>\n\n	<p>这项设置对于用户端是慢速网络或网页内容比较庞大的情况比较有利，可以在网页逐步呈现的同时仍会保持格式信息，不影响网页美感。</p>\n	</li>\n	<li>\n	<p>Javascript脚本放在文件末尾</p>\n\n	<p>很多Javascript脚本执行效率低下，或者有的第3方域名脚本出现意外无法载入， 如果将这些脚本放置到页面比较靠前的位置，可能会导致我们自己网站的内容载入速度下降甚至无法正常加载，所以一般将这些脚本放置在网页文件末尾，一定要放 置在前面的脚本要改用所谓的&ldquo;后载入&rdquo;方式加载，在主体网页加载完成后再加载，防止其影响到主体网页的加载速度。</p>\n	</li>\n	<li>\n	<p>避免使用CSS脚本(CSS Expressions)</p>\n\n	<p>有时为了要css的参数动态改变，可能会采用css expression来实现，但这样做得不偿失，会使用户端浏览器负担明显加重，所以不建议这样做，如果需要改变，可以使用Javascript脚本去实现。</p>\n	</li>\n	<li>\n	<p>css、javascript改由外部调用</p>\n\n	<p>如果css、js内容比较庞大，尽量不要写到同1个页面中去，改由外部载入比较妥当，因为浏览器本身会对css、js文件进行缓存。</p>\n	</li>\n	<li>\n	<p>压缩Javascript、CSS代码</p>\n\n	<p>一般js、css文件中存在大量的空格、换行、注释，这些利于阅读，如果能够压缩掉，将会很有利于网络传输。这方面的工具也有很多，一般可以保留开发版本，利用工具生成生产版本，2个文件比较，一般压缩率能达到50%以上，减少的数据量还是比较可观的。</p>\n	</li>\n	<li>\n	<p>避免采用301、302转向</p>\n	</li>\n	<li>\n	<p>养成良好的开发维护习惯，尽量避免脚本重复调用</p>\n	</li>\n	<li>\n	<p>配置ETags</p>\n	</li>\n	<li>\n	<p>Ajax采用缓存调用</p>\n\n	<p>这个的使用可以参照Discuz论坛代码，里面对于大量使用的Ajax调用都采用了缓存 调用方式，一般采用附加特征参数方式实现，注意其中的</p>\n\n	<p>&lt;script src=&rdquo;xxx.js?{VERHASH}&rdquo;，{VERHASH}&nbsp;<br />\n	就是特征参数，这个参数不变化就使用缓存文件，如果发生变化则重新下载新文件或更新信 息。</p>\n	</li>\n	<li>\n	<p>合理使用Flush</p>\n\n	<p>用户端发送浏览请求后，服务器端一般要花销200-500ms去处理这些请求，在此期间，用户端浏览器处于等待状态，如果要减少用户等待时间，可以在适当的位置使用flush，将已经就绪的内容推送到用户端，这在php中很容易实现例如：</p>\n\n	<pre class="linenums" id="prettyprint">\n&lt;!-- css, js --&gt; \n&lt;/head&gt; \n&lt;?php flush();?&gt; \n&lt;body&gt; \n... &lt;!-- content --&gt; </pre>\n	</li>\n	<li>\n	<p>Ajax调用尽量采用GET方法调用</p>\n\n	<p>实际使用XMLHttpRequest时，如果使用POST方法实现，会发生2次HTTP请求，而使用GET方法只会发生1次HTTP请求。如果改用GET方法，HTTP请求减少50%！</p>\n	</li>\n	<li>\n	<p>尽可能减少DCOM元素</p>\n\n	<p>这个很好理解，就是尽可能减少网页中各种&lt;&gt;元素数量，例如&lt;table&gt;的冗余很严重，而我们完全可以用&lt;div&gt;取代之。</p>\n	</li>\n	<li>\n	<p>使用多域名负载网页内的多个文件、图片</p>\n\n	<p>记得有资料说明，IE在网页载入过程中，在同1时刻，对同1域名并行加的HTTP请求数 量最高为2个，如果网页需要加载的文件数量超过2个(通常远远超过..)，要加快网页访问速度，最好将文件分布到多个域名，例如19楼，其js文件采用独 立的域名，据说百度的图片服务器数量在20台以上。</p>\n	</li>\n	<li>\n	<p>缩减iframe的使用，如无必要，尽量不要使用</p>\n\n	<p>iframe通常用于不同域名内容的加载，这同时也可能因iframe内容加载速度影响到主网页加载速度，如果可能，把需要加载的内容抓取到本地直接嵌入。如果实在需要iframe加载，采用后载入方式实现。</p>\n	</li>\n	<li>\n	<p>优化图片文件</p>\n\n	<p>优化图片文件，减小其尺寸，特别是缩略图，一定要按尺寸生成缩略图然后调用，不要在网页中用resize方法实现，虽然这样看到的图片外形笑了，但是其加载的数据量一点也没减少。曾经见过有人在网页中加载的缩略图，其真实尺寸有10M之巨&hellip;</p>\n\n	<p>普通图像、icon也要尽可能压缩后，可以采用web图像保存、减少颜色数等等方法实现。</p>\n	</li>\n	<li>\n	<p>当页面内容庞大到一定程度，可以采用分页的方式展现，或者taobao的那种翻页后载入方式。</p>\n	</li>\n</ul>\n</blockquote>\n\n<p>４、如何对网站的文件和资源进行优化</p>\n\n<blockquote>\n<ul>\n	<li>文件合并</li>\n	<li>文件最小化/文件压缩</li>\n	<li>使用CDN托管</li>\n	<li>缓存的使用</li>\n	<li>其他&nbsp;</li>\n</ul>\n</blockquote>\n\n<p>５、语义化的HTML</p>\n\n<blockquote>\n<ul>\n	<li>什么是HTML语义化<br />\n	&lt;基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等&gt; 　　根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li>\n	<li>为什么要语义化<br />\n	为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>\n	<li>写HTML代码时应注意什么<br />\n	尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li>\n</ul>\n</blockquote>\n\n<p>６、渐进增强和优雅降级之间的不同</p>\n\n<blockquote>\n<ul>\n	<li>优雅降级：<br />\n	使用优雅降级方案，Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，绝大多数Web设计师和开发者都通过专门的样式表或针对不同版本的IE的hack实践过优雅降级了； 使用优雅降级技术时，你必须首先完整的实现了网站，其中包括所有的功能和效果。然后再为那些无法支持所有功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。</li>\n	<li>渐进增强：<br />\n	从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能。渐进增强是值得所有开发者采用的做法。渐进增强方案并不假定所有用户都支持javascript，而总是提供一种候补方法，确保用户可以访问（主要的）内容。 使用渐进增强时，无需为了一个已成型的网站在旧式浏览器下正常工作而做逆向工程。首先，只需要为所有的设备和浏览器准备好清晰且语义化的HTML以及完善的内容，然后再以无侵入（unobtrusive）的方式向页面增加无害于基础浏览器的额外样式和功能。当浏览器升级时，它们会自动地呈现出来并发挥作用。<br /><br />\n	想让网站在任何环境下看起来都保持一致是不可能的，不管为此付出多少努力，结局依旧会令你失望。与其试图让IE看起来堪比年轻它十岁的浏览器，不如努力改善网站的可访问性，或是进行更多的可用性测试，而不仅仅是让页面看起来&ldquo;更靓一点&rdquo;。 某些CSS3特性在不支持它的浏览器中简直是&ldquo;无法模拟实现&rdquo;的，但若使用渐进增强，就无需为了能让你的网站适合所有人而放弃这些技术。仅仅因为部分人不愿或不能升级浏览器，却让使用新型浏览器的用户无法享受CSS3所提供的伟大技术，这是毫无道理可言的。<br /><br />\n	我们应该先让网站能够正常工作于尽可能旧的浏览器上，然后不断为它在新型浏览器上实现更多的增强和改进。随着时间的推移，当越来越多的人开始升级浏览器而浏览器本身的支持度也不断提升时，就会有越来越多的人体验到这些增强和改进，它持续有效的使网站越来越好，却如需你刻意做什么。只需要一次实现，它就让网站的体验与时俱进。</li>\n</ul>\n</blockquote>\n', ' html总结 ', '', 9, ' 2014 ', ' Aug ', ' 1 '),
(51, '2014-10-21 08:40:36', ' <p>１、&lsquo;$&rsquo; 和 &lsquo;$.fn&rsquo; 的区别</p>\n\n<blockquote>\n<ul>\n	<li>$.fn是指jquery的命名空间，加上fn上的方法及属性，会对jquery实例每一个有效。&nbsp;<br />\n	如扩展$.fn.abc()&nbsp;<br />\n	那么你可以这样子：$(&quot;#div&quot;).abc();&nbsp;<br />\n	通常使用extend方法扩展，详细请看API.&nbsp;</li>\n	<li>$.fx是指jquery的特效。&nbsp;<br />\n	如果使用显示、滑动、淡入淡出、动画等。&nbsp;<br />\n	$.fx.off可以关闭动画，其实是直接显示结果。</li>\n</ul>\n</blockquote>\n\n<p>&nbsp;<em>２、</em>.bing()、.live()和.delegate()的区别</p>\n\n<blockquote>\n<p>&nbsp;</p>\n</blockquote>\n\n<p>３、get()和eq()的区别</p>\n\n<blockquote>\n<ul>\n	<li>\n	<pre>\neq返回的是一个jquery对象</pre>\n	</li>\n	<li>\n	<pre>\nget返回的是一个html&nbsp;对象数组</pre>\n	</li>\n	<li>\n	<p>返回的是jQuery对象，就可以继续调用其他方法，返回的是html数组就不能调用jQuery的其他方法</p>\n	例如：\n\n	<pre class="linenums" id="prettyprint">\n$(&quot;ul&nbsp;li&quot;).get(1).css(&quot;color&quot;,&nbsp;&quot;red&quot;);&nbsp;//这个是错误的\n$(&quot;ul&nbsp;li&quot;).eq(1).css(&quot;color&quot;,&nbsp;&quot;red&quot;);&nbsp;&nbsp;//这个是正确的</pre>\n	</li>\n</ul>\n</blockquote>\n\n<p>４、传递到jQuery方法的四种不同值</p>\n\n<blockquote>\n<ul>\n	<li>选择器（字符串），HTML（字符串），回调函数，HTML元素，对象，数组，元素数组，jQuery对象等</li>\n</ul>\n</blockquote>\n ', ' jquery总结 ', '', 9, ' 2014 ', ' Jul ', ' 27 '),
(52, '2014-10-21 08:40:36', '<p>modern workflows for modern webapps 具体指的是yeo、grunt、bower<br />\n------------------------------------<br />\n首先是grunt：the javascript task runner</p>\n\n<p>package.json：放置于项目的根目录中，内容为项目用到了哪些npm模块，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交。在上述目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖。</p>\n\n<p>Gruntfile: 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件，简单说就是grunt的配置文件<br />\n------------------------------------<br />\n下面我们仔细看这个Gruntfile配置文件<br />\ngrunt.initConfig初始化配置文件<br />\npkg: grunt.file.readJSON(&#39;tiny-pubsub.jquery.json&#39;),是pkg加载的tiny-pubsub.jquery.json是项目介绍信息的存储文件<br />\nbanner: 在项目生成的文件上面加上pkg内的文件注释<br />\nclean删除目录<br />\nconcat是把我们的js文件做一个合并（在项目中把分开写的js文件合并为一个js文件）<br />\nuglify是js的node版本的压缩工具<br />\nqunit做 qunit测试<br />\njshint检测代码的书写、格式是否规范<br />\nwatch监听需要watch的文件，</p>\n\n<p>&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-clean&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-qunit&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);<br />\n是加载插件模块<br />\ngrunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;qunit&#39;, &#39;clean&#39;, &#39;concat&#39;, &#39;uglify&#39;]);<br />\n是注册任务名称，名称后面括号内是任务执行时以来的插件模块<br />\n---------------------------<br />\nnpm init&nbsp;<br />\nnpm init命令会创建一个基本的package.json文件<br />\n在一个新建的项目中命令行执行npm init 会提示项目名称、版本号、描述、入口点、测试命令等，然后会自动帮你生成package.json文件<br />\n------------------------------------<br />\noptions<br />\ngruntfile.js配置文件，concat任务中的options就是任务的配置项，options可以写在concat中，也可以写在concat的dist中<br />\n----------------------------------------<br />\nfiles<br />\n文件匹配提供了两个属性：src和dest，src是原目录，dest目标目录<br />\nfiles的dot和expand属性<br />\nexpand处理动态文件匹配<br />\ncmd属性，举例：当src属性目录为usr/lib时，cmd设置为usr，则src省略usr只需设置为lib<br />\nflatten属性，去掉所有路径，只保留文件名</p>\n', ' grunt简介 ', '', 10, ' 2014 ', ' May ', ' 11 '),
(53, '2014-10-21 08:40:36', ' <p>Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。，同时如果你是用Grunt 0.4.x版本的Grunt必须配合Node.js &gt;= 0.8.0版本使用</p>\n\n<p>安装 CLI</p>\n\n<p>首先需要将Grunt命令行（CLI）安装到全局环境中</p>\n\n<p>执行命令&nbsp;</p>\n\n<p>npm install -g grunt-cli</p>\n\n<p>（安装了grunt-cli并不等于已经安装了 Grunt ，Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt，可以让多个版本的 Grunt 同时安装在同一台机器上。</p>\n\n<p>CLI 是如何工作的</p>\n\n<p>每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt，正是由于这一机制，你可以在项目的任意子目录中运行grunt，如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。</p>\n\n<p>拿一份现有的 Grunt 项目练手</p>\n\n<p>假定Grunt CLI已经正确安装，并且已经有一份配置好package.json 和 Gruntfile 文件的项目了，接下来就很容易拿Grunt练手了：</p>\n\n<p>将命令行的当前目录转到项目的根目录下。</p>\n\n<p>执行npm install命令安装项目依赖的库。</p>\n\n<p>执行 grunt 命令。</p>\n\n<p>OK，就是这么简单。还可以通过grunt --help 命令列出所有已安装的Grunt任务（task），但是一般更建议去查看项目的文档以获取帮助信息。</p>\n\n<p>grunt简单示例：jquery-tiny-pubsub project（https://github.com/cowboy/jquery-tiny-pubsub）</p>\n ', ' grunt安装 ', '', 10, ' 2014 ', ' May ', ' 12 '),
(54, '2014-10-21 08:40:36', '<p>concat，是把我们的js文件做一个合并（在项目中把分开写的js文件合并为一个js文件）<br />\nuglify，是js的node版本的压缩工具<br />\nqunit，做 qunit测试<br />\njshint，检测代码的书写、格式是否规范<br />\nwatch，监听需要watch的文件，<br />\n-------------------<br />\n安装Grunt 和 grunt插件</p>\n\n<p>向已经存在的package.json 文件中添加Grunt和grunt插件的最简单方式是通过npm install &lt;module&gt; --save-dev命令。此命令不光安装了&lt;module&gt;，还会自动将其添加到devDependencies 配置段中，遵循tilde version range格式。</p>\n\n<p>例如，下面这条命令将安装Grunt最新版本到项目目录中，并将其添加到devDependencies内：</p>\n\n<p>npm install grunt --save-dev<br />\n同样，grunt插件和其它node模块都可以按相同的方式安装。安装完成后一定要记得将被修改的package.json文件提交到源码管理器中。</p>\n\n<p>Gruntfile<br />\nGruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级，并和项目源码一起加入源码管理器。</p>\n\n<p>Gruntfile由以下几部分构成：</p>\n\n<p>&quot;wrapper&quot; 函数<br />\n项目与任务配置<br />\n加载grunt插件和任务<br />\n自定义任务<br />\nGruntfile文件案例</p>\n\n<p>在下面列出的这个 Gruntfile 中，package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中， grunt-contrib-uglify 插件中的uglify 任务（task）被配置为压缩（minify）源码文件并依据上述元数据动态生成一个文件头注释。当在命令行中执行 grunt 命令时，uglify 任务将被默认执行。</p>\n\n<pre class="linenums" id="prettyprint">\nmodule.exports = function(grunt) {\n\n  // Project configuration.\n  grunt.initConfig({\n    pkg: grunt.file.readJSON(&#39;package.json&#39;),\n    uglify: {\n      options: {\n        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39;\n      },\n      build: {\n        src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,\n        dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39;\n      }\n    }\n  });\n\n  // 加载包含 &quot;uglify&quot; 任务的插件。\n  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);\n\n  // 默认被执行的任务列表。\n  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);\n\n};</pre>\n\n<p>前面已经向你展示了整个 Gruntfile，接下来将详细解释其中的每一部分。</p>\n\n<p>&quot;wrapper&quot; 函数</p>\n\n<p>每一份 Gruntfile （和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</p>\n<pre class="linenums" id="prettyprint">\n<p>module.exports = function(grunt) {\n&nbsp; // Do grunt-related things in here\n};</pre>\n项目和任务配置</p>\n\n<p>大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig 方法。</p>\n\n<p>在下面的案例中，grunt.file.readJSON(&#39;package.json&#39;) 将存储在package.json文件中的JSON元数据引入到grunt config中。 由于&lt;% %&gt;模板字符串可以引用任意的配置属性，因此可以通过这种方式来指定诸如文件路径和文件列表类型的配置数据，从而减少一些重复的工作。</p>\n\n<p>你可以在这个配置对象中(传递给initConfig()方法的对象)存储任意的数据，只要它不与你任务配置所需的属性冲突，否则会被忽略。此外，由于这本身就是JavaScript，你不仅限于使用JSON；你可以在这里使用任意的有效的JS代码。如果有必要，你甚至可以以编程的方式生成配置。</p>\n\n<p>与大多数task一样，grunt-contrib-uglify 插件中的uglify 任务要求它的配置被指定在一个同名属性中。在这里有一个例子, 我们指定了一个banner选项(用于在文件顶部生成一个注释)，紧接着是一个单一的名为build的uglify目标，用于将一个js文件压缩为一个目标文件。</p>\n<pre class="linenums" id="prettyprint">\n<p>// Project configuration.\ngrunt.initConfig({\n&nbsp; pkg: grunt.file.readJSON(&#39;package.json&#39;),\n&nbsp; uglify: {\n&nbsp; &nbsp; options: {\n&nbsp; &nbsp; &nbsp; banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39;\n&nbsp; &nbsp; },\n&nbsp; &nbsp; build: {\n&nbsp; &nbsp; &nbsp; src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,\n&nbsp; &nbsp; &nbsp; dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39;\n&nbsp; &nbsp; }\n&nbsp; }\n});\n</pre>\n加载 Grunt 插件和任务</p>\n\n<p>像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：</p>\n\n<p>// 加载能够提供&quot;uglify&quot;任务的插件。<br />\ngrunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);<br />\n注意： grunt --help 命令将列出所有可用的任务。</p>\n\n<p>自定义任务</p>\n\n<p>通过定义 default 任务，可以让Grunt默认执行一个或多个任务。在下面的这个案例中，执行 grunt 命令时如果不指定一个任务的话，将会执行uglify任务。这和执行grunt uglify 或者 grunt default的效果一样。default任务列表数组中可以指定任意数目的任务（可以带参数）。</p>\n\n<p>// Default task(s).<br />\ngrunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);<br />\n如果Grunt插件中的任务（task）不能满足你的项目需求，你还可以在Gruntfile中自定义任务（task）。例如，在下面的 Gruntfile 中自定义了一个default 任务，并且他甚至不依赖任务配置：</p>\n\n<pre class="linenums" id="prettyprint">\nmodule.exports = function(grunt) {\n\n  // A very basic default task.\n  grunt.registerTask(&#39;default&#39;, &#39;Log some stuff.&#39;, function() {\n    grunt.log.write(&#39;Logging some stuff...&#39;).ok();\n  });\n\n};</pre>\n\n<p>特定于项目的任务不必在 Gruntfile 中定义。他们可以定义在外部.js 文件中，并通过grunt.loadTasks 方法加载。</p>\n', ' 五个基础的task ', '', 10, ' 2014 ', ' May ', ' 13 '),
(55, '2014-10-21 08:40:36', ' <p>contrib-connect，本地产生一个service，可以实时看到代码产生的效果<br />\ncontrib-htmlmin，html压缩<br />\ncontrib-requirejs<br />\nmocha，测试框架<br />\nautoprefixer，<br />\nrev，生成静态的md5文件名<br />\nusemin，<br />\ncontrib-compass，用来处理css文件<br />\ncontrib-imagemin<br />\nsvgmiin<br />\nconcurrent</p>\n ', ' 进阶task ', '', 10, ' 2014 ', ' May ', ' 14 '),
(56, '2014-10-21 08:40:36', '<p>首先在官网(http://nodejs.org/)下载Nodejs： node-&lt;版本号&gt;.tar.gz<br />\n以我的为例：node-v0.10.29.tar.gz</p>\n\n<p>安装nodejs所要依赖的包<br />\nsudo apt-get install build-essential &nbsp; &nbsp; //gcc<br />\nsudo apt-get install libssl-dev &nbsp; &nbsp;//ssl</p>\n\n<p>我们可以先在usr/local下创建一个文件夹<br />\ncd /usr/local<br />\nmkdir node<br />\n然后把node-v0.10.29.tar.gz复制到usr/local目录下<br />\nmv node-v0.10.29.tar.gz /usr/local<br />\n执行解压命令<br />\ntar zxvf node-v0.10.29.tar.gz<br />\n进入解压目录node-v0.10.29<br />\ncd node-v0.10.29<br />\n执行安装命令<br />\n./configure --prefix=/usr/local/node &nbsp;制定编译路径<br />\nmake<br />\nsudo make install<br />\n三种方法配置环境变量，注意 root 权限和普通用户权限<br />\necho &lsquo;export PATH=/usr/local/node/bin:$PATH&rsquo; &gt;&gt; ~/.profile 设置环境变量 &nbsp;<br />\necho &lsquo;export NODE_PATH=/usr/local/node:/usr/local/node/lib/node_modules&rsquo; &gt;&gt; ~/.profile &nbsp; 设置NODE_PATH &nbsp;<br />\nsource ~/.profile</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416277522.png" style="height:481px; width:856px" /><br />\n或者通过执行sudo gedit /etc/environment 将 bin 加入环境变量，然后执行 source /etc/environment 使它立即生效</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/14141627819.png" style="height:481px; width:856px" /></p>\n\n<p>或者也可以 sudo gedit ~/.bashrc 在文件末尾加入变量<br />\nexport PATH=/usr/local/node/bin:$PATH<br />\nexport NODE_PATH=/usr/local/node:/usr/local/node/lib/node_modules<br />\n执行 source ~/.bashrc 立即生效</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416278942.png" style="height:481px; width:856px" /><br />\n安装完成后，验证是否安装成功，输入node &ndash;v<br />\n新版本的nodejs自带npm，输入npm &ndash;v</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416280572.png" style="height:481px; width:856px" /><br />\n用npm安装express<br />\nnpm install express -gd （在ubuntu 下要切换root权限安装）</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416281317.png" style="height:481px; width:856px" /></p>\n\n<p>-g代表安装到NODEPATH的lib里面，而-d代表把相依性套件也一起安装。如果沒有-g的话会安装目前所在的目录(会建立一个nodemodules的文件夹)</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416281815.png" style="height:481px; width:856px" /><br />\n验证是否安装成功：<br />\n之前我们通过 npm install express -gd 安装的 express 对它通过 npm -list 再次验证</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416282477.png" style="height:481px; width:856px" /></p>\n\n<p>可以看到已经安装完成的 express@4.6.1&nbsp;<br />\n我们执行 express --version 命令<br />\nexpress --version</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416283149.png" style="height:481px; width:856px" /></p>\n\n<p>显示为程序 &quot;express&quot; 尚未安装，会提示 apt-get install node-express ( ubuntu 源中的 express )<br />\n这是因为 express 默认安装是最新的版本，已经是4.x.x的版本。而最新express4.0+版本中将命令工具分出来了，所以必须要安装express-generator，执行：<br />\nnpm install express-generator -gd</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416282904.png" style="height:481px; width:856px" /></p>\n\n<p>安装 express-generato 再执行 express --version 或者 express -V</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286917.png" style="height:640px; width:856px" /></p>\n\n<p>从图中我们可以看到 express 命令已经生效，显示版本为 express 4.2.0，（但是我们安装的是 express 4.6.1，为什么显示为 4.2.0 呢，这个我也搞不懂，后来才知道4.2.0是 express-generator 的版本号）<br />\n---------------------------------------------------------------------------------<br />\n或者我们也可以按照官网的步骤<br />\n在自己设定的工程目录下（如我的nodework目录）<br />\ncd /home/kahn/nodework<br />\n输入 npm info express version 查看最新版本号</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416283535.png" style="height:640px; width:856px" /></p>\n\n<p>编写package.json文件<br />\nvim package.json 或者 gedit package.json</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416284178.png" style="height:640px; width:856px" /></p>\n\n<p>输入 npm install 安装项目</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416284851.png" style="height:640px; width:856px" /></p>\n\n<p>输入 npm ls 验证 express 是否安装并显示 express 包及其依赖关系</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286391.png" style="height:640px; width:856px" /></p>\n\n<p>我在官网(http://nodejs.org/)看到的教程，在当前工程目录下创建app.js文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286112.png" style="height:481px; width:856px" /></p>\n\n<p>输入 node app.js 启动 app.js 在浏览器输入 localhost:3000/hello.txt</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286229.png" style="height:481px; width:856px" /></p>\n', ' node笔记（一）', '', 11, ' 2014 ', ' May ', ' 14 '),
(57, '2014-10-21 08:40:36', ' <p>​在我的用户目录下建立nodework文件夹方便管理nodejs工程<br />\ncd /home/kahn<br />\nmkdir nodework<br />\n进入nodework<br />\ncd nodework<br />\n新建一个工程把nodespace文件夹作为我们的工程目录<br />\nexpress -e nodespace</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416288625.png" style="height:481px; width:856px" /></p>\n\n<p>我们打开原本空的nodework文件夹就会发现自动生成nodespace文件夹，并且nodespace中生成了许多文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416289299.png" style="height:481px; width:856px" /></p>\n\n<p>我们也可以通过桌面文件浏览器查看这些文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416288511.png" style="height:481px; width:856px" /></p>\n\n<p>在express 3.x版本中我们使用ejs时不再是 -t ejs，而是 -e．可以通过输入express -h 查看</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416290105.png" style="height:481px; width:856px" /></p>\n\n<p>如果命令行现在已经在nodespace文件夹中 输入 npm install 安装所需模块<br />\n否则通过 cd /home/kahn/nodework/nodespace &amp; npm install 安装所需模块</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/14141629074.png" style="height:481px; width:856px" /></p>\n\n<p>&nbsp;安装完毕之后输入 node app</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416291307.png" style="height:481px; width:856px" /></p>\n\n<p>我们打开浏览器输入localhost:3000查看效果</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416290522.png" style="height:481px; width:856px" /></p>\n\n<p>很明显我的安装出现了问题，通过调试进行更改<br />\n首先打开layout.jade文件（需要root权限）</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/14141629124.png" style="height:481px; width:856px" /></p>\n\n<p>layout.jade内容如下</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416292874.png" style="height:481px; width:856px" /></p>\n\n<p>我们把第一行的 !!! 更改为 doctype html&nbsp;</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416292569.png" style="height:481px; width:856px" /></p>\n\n<p>重新刷新浏览器localhost:3000地址</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416292672.png" style="height:481px; width:856px" /></p>\n\n<p>到这里我们已经成功部署了一个express工程项目，并指定了ejs模板引擎。</p>\n \n', ' node笔记（二） ', '', 11, ' 2014 ', ' May ', ' 14 '),
(58, '2014-10-21 08:40:36', '<p>​通过前两篇笔记完成了node.js的服务器部署</p>\n<p>​express是一款很优秀的mvc框架</p>\n<p>​node.js的express工程目录如下</p>\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294135.png" style="height:481px; width:856px" /></p>\n\n<p>其中<br />\napp.js是启动文件（入口文件）<br />\npackage.json存储工程信息及模块依赖，当在dependencies中添加依赖模块时，运行 npm install ，npm 会自动检查当前目录下的 &nbsp; &nbsp; &nbsp; &nbsp;package.json，并自动安装所有指定的模块<br />\nnode_modules存放package.json中安装的模块，当你在package,json中添加依赖的模块并用 npm install 安装完毕之后，该模块会被放在node_modules文件夹中<br />\npublic存放image css js 等文件<br />\nroutes顾名思义存放路由文件<br />\nviews存放视图文件<br />\n然后首先我们先打开app.js看看其中都写了什么</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294809.png" style="height:481px; width:856px" /><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294003.png" style="height:481px; width:856px" /></p>\n\n\n\n代码如下\n-------------------------------------------------------------------------------------------------------------------------\n<pre class="linenums prettyprint" id="prettyprint">\n/**\n * Module dependencies.\n */\n\nvar express = require(&#39;express&#39;)\n  , routes = require(&#39;./routes&#39;);\n\nvar app = module.exports = express.createServer();\n\n// Configuration\n\napp.configure(function(){\n  app.set(&#39;views&#39;, __dirname + &#39;/views&#39;);\n  app.set(&#39;view engine&#39;, &#39;ejs&#39;);\n  app.engine(&#39;.html&#39;,require(&#39;ejs&#39;),_express); #把 ejs 扩展文件名为html\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  app.use(app.router);\n  app.use(express.static(__dirname + &#39;/public&#39;));\n});\n\napp.configure(&#39;development&#39;, function(){\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n});\n\napp.configure(&#39;production&#39;, function(){\n  app.use(express.errorHandler());\n});\n\n// Routes\n\napp.get(&#39;/&#39;, routes.index);\n\napp.listen(3000, function(){\n  console.log(&quot;Express server listening on port %d in %s mode&quot;, app.address().port, app.settings.env);\n});\n</pre>\n-------------------------------------------------------------------------------------------------------------------------\n这段代码用中文解释就是\n<pre class="linenums prettyprint" id="prettyprint">\n/**\n * 模块 依赖.\n */\n定义 express 并通过 require() 加载 express 模块\n定义 routes 并通过 require() 加载 routes 文件夹以及routes下的index.js等所有文件\n定义 app 并通过 module.exports 接口创建 express服务</pre>\n....................\n------------------------------------------------------------------------------------------------------------------\n我通过改写  app.set(&#39;view engine&#39;, &#39;jade&#39;); 为  app.set(&#39;view engine&#39;, &#39;ejs&#39;); 让它支持ejs引擎，但是结果nodejs又出现了新问题，如下图\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294184.png" style="height:481px; width:856px" /></p>\n\n<p>发现views里没有ejs格式的文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294665.png" style="height:481px; width:856px" /></p>\n\n<p>创建index.ejs<br />\n内容设置为<br />\n&lt;p&gt;this is .ejs.&lt;/p&gt;<br />\n同时复制一份layout.jade文件为layout.ejs</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416295978.png" style="height:481px; width:856px" /></p>\n\n<p>打开浏览器仍有错误，提示为没有安装ejs模块</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416295165.png" style="height:481px; width:856px" /></p>\n\n<p>安装ejs模块<br />\n在nodespace文件夹下输入 npm install ejs<br />\n安装完毕后打开浏览器localhost:3000</p>', ' node笔记（三） ', '', 11, ' 2014 ', ' May ', ' 15 '),
(59, '2014-10-25 08:35:55', ' <p>这几天看杜欢、王群锋翻译的《数据结构与算法javascript描述》，就想着写几篇笔记方便日后浏览。</p>\n\n<p>快速排序主要用到了递归，以每个数组的第一个数字作为基准值进行算法排序，示例代码如下：</p>\n\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n    var list=[44,75,23,43,55,12,64,77,33];\n    function qSort(list){\n        if(list.length==0){\n            return [];\n        }\n        var lesser=[];\n        var greater=[];\n        var pivot=list[0];\n        for (var i=1;i&lt;list.length;i++){\n            if(list[i]&lt;pivot){\n                lesser.push(list[i]);\n                console.log(lesser+&quot;+lesser&quot;);\n            }else{\n                greater.push(list[i]);\n                console.log(greater+&quot;+greater&quot;);\n            }\n        }\n        return qSort(lesser).concat(pivot,qSort(greater));\n    }\n    console.log(qSort(list));\n    &lt;/script&gt;</pre>\n\n<p>在控制台中console.log，打印信息如下：</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141419743445.png" style="height:481px; width:856px" /></p>\n\n<p>从图中可以很清晰看到算法首先以44为基准值，分成了[23,43,12,33]和[75,55,64,77]两个数组，</p>\n\n<p>继续以23和75为基准值，分成了[12]、[43,33]和[55,64]、[77]四个数组，</p>\n\n<p>[43,33]和[55,64]又分别已43、55继续拆分，</p>\n\n<p>最后重组得到[12, 23, 33, 43, 44, 55, 64, 75, 77]</p>\n ', ' 快速排序 ', '', 12, ' 2014', ' Jan ', ' 1 '),
(60, '2014-10-25 08:54:02', '<p>自底向上归并首先将数据集合分割成单个数组（每个数组中有且仅有一个元素），</p>\n\n<p>然后通过创建一组左右子数组将它们慢慢合并，</p>\n\n<p>每次合并都保存一部分排序好的数据集合，最终合并成完美的集合，代码如下：</p>\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n    function mergeSort( arr ) {\n        if ( arr.length &lt; 2 ) {\n            return;\n        }\n        var step = 1;\n        var left, right;\n        while ( step &lt; arr.length ) {\n            left = 0;\n            right = step;\n            while ( right + step &lt;= arr.length ) {\n                mergeArrays(arr, left, left+step, right, right+step);\n                console.log(&#39;arr:&#39;+arr+&#39;---/---left:&#39;+left+&#39;---/---left+step:&#39;+left+step+&#39;---/---right:&#39;+right+&#39;---/---right+step:&#39;+right+step);\n                left = right + step;\n                right = left + step;\n                console.log(&#39;循环一次结束&#39;+&#39;::::left:::&#39;+left+&#39;::::right:::&#39;+right+&#39;::::step:::&#39;+step);\n            }\n            if ( right &lt; arr.length) {\n                mergeArrays(arr, left, left+step, right, arr.length);\n                console.log(&#39;if::::::::::&#39;+&#39;arr:&#39;+arr+&#39;---/---left:&#39;+left+&#39;---/---left+step:&#39;+left+step+&#39;---/---right:&#39;+right+&#39;---/---arr.length:&#39;+arr.length);\n            }\n            step *=2;\n            console.log(&#39;step:::::&#39;+step);\n        }\n    }\n    function mergeArrays( arr, startLeft, stopLeft, startRight, stopRight) {\n        var rightArr = new Array(stopRight - startRight +1);\n        var leftArr = new Array(stopLeft - startLeft +1);\n        k = startRight;\n        for (var i = 0; i &lt; ( rightArr.length-1 ); ++i) {\n            rightArr[ i ] = arr[ k ];\n            ++k;\n        }\n        k = startLeft;\n        for (var i = 0;i &lt; ( leftArr.length-1); ++i) {\n            leftArr[ i ] = arr[ k ];\n            ++k;\n        }\n        rightArr[ rightArr.length-1 ] = Infinity;\n        leftArr[ leftArr.length-1 ] = Infinity;\n        var m = 0;\n        var n = 0;\n        for (var k = startLeft; k &lt; stopRight; ++k){\n            if ( leftArr[ m ] &lt;= rightArr[ n ]) {\n                arr[ k ] = leftArr[ m ];\n                m++;\n            }\n            else {\n                arr[ k ] = rightArr[ n ];\n                n++;\n            }\n        }\n    }\n    var list=[44,75,23,43,55,12,64,77,33];\n    console.log(list);\n    mergeSort(list)\n    console.log(list);\n    &lt;/script&gt;</pre>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141429742368.png" style="height:481px; width:856px" /></p>\n', ' 归并排序', '', 12, ' 2014 ', ' Oct ', ' 23 '),
(61, '2014-10-25 08:54:02', '<p>希尔排序是插入排序的升级版本，1959年希尔通过将简单排序中两两比较改为设置步长跳跃式比较而突破了n的平方的时间复杂度,</p>\n\n<p>希尔排序的核心理念是它会首先选择较远的元素进行比较，这种方案可以使距离较远的元素更快的回到合适的位置，</p>\n\n<p>这里我们使用【５，３，１】作为间隔序列。代码如下:</p>\n\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n        var list=[44,75,23,43,55,12,64,77,33];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function sellsort(){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var gaps=[ 5, 3, 1];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for ( var g = 0; g &lt; gaps.length; ++g){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for ( var i = gaps[ g ]; i &lt; list.length; ++i ){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var temp = list[ i ];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for ( var j = i; j &gt;= gaps[ g ] &amp;&amp; list[ j - gaps[ g ]] &gt; temp; j -= gaps[ g ] ){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list[ j ] = list[ j - gaps[ g ]];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list[ j ] = temp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var q=i-gaps[ g ]+1;document.write(&#39;以&#39;+gaps[ g ]+&#39;为间隔序列的第&#39;+q+&#39;次：&#39;+list+&#39;&lt;br/&gt;&#39;);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}document.write(&#39;&lt;br/&gt;&#39;);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}console.log(list);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;};\n        sellsort();\n    &lt;/script&gt;</pre>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141439048768.png" style="height:481px; width:856px" /></p>\n', '希尔排序 ', '', 12, ' 2014 ', ' Apr ', ' 4 '),
(62, '2014-10-27 15:05:52', '<p>堆排序是选择排序的升级，通过不断构建大顶堆或者小顶堆来选择最大或者最小的值放入队列前端进行排序，</p>\n\n<p>堆排序任何情况下的时间复杂度都为O(N*logN)，</p>\n\n<p>可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶，</p>\n\n<p>示例代码如下:</p>\n\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n        var list=[44,75,23,43,55,12,64,77,33];\n        function heapSort(array) {\n                        var temp;\n                        var i;\n                        for (i = Math.floor(array.length / 2); i &gt;= 0; i--) {\n                            heapAdjust(array, i, array.length - 1); //将数组array构建成一个大顶堆\n                        }\n                        for (i = array.length - 1; i &gt;= 0; i--) {\n                            /*把根节点交换出去*/\n                            temp = array[i];\n                            array[i] = array[0];\n                            array[0] = temp;\n                            /*余下的数组继续构建成大顶堆*/\n                            heapAdjust(array, 0, i - 1);\n                            /* 输出结果 */\n                            document.write(&quot;&lt;br /&gt;&lt;br /&gt;第&quot; + (array.length - i).toString() + &quot;遍排序的结果是:&quot;);\n                            for (var n = 0; n &lt; array.length; n++) {\n                                    document.write(array[n] + &quot;,&quot;);\n                            }\n                            /* 输出结果结束 */\n                        }\n                }\n                //要调整的子树\n                //start为数组开始下标\n                //max是数组结束下标\n                function heapAdjust(array, start, max) {\n                        var temp, j;\n                        temp = array[start];//temp是根节点的值\n                        for (j = 2 * start; j &lt; max; j *= 2) {\n                        if (j &lt; max &amp;&amp; array[j] &lt; array[j + 1]) {  //取得较大孩子的下标\n                                ++j;\n                        }\n                        if (temp &gt;= array[j])\n                            break;\n                        array[start] = array[j];\n                        start = j;\n                    }\n                array[start] = temp;\n    }\n    heapSort(list);\n    &lt;/script&gt;</pre>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141439362261.png" style="height:481px; width:856px" /></p>\n', ' 堆排序 ', '', 12, ' 2014 ', ' Aug ', ' 8 ');

-- --------------------------------------------------------

--
-- 表的结构 `k_domainnameshop`
--

CREATE TABLE IF NOT EXISTS `k_domainnameshop` (
  `kt_domainnameshop_ids` int(11) NOT NULL AUTO_INCREMENT,
  `kt_domainnameshop_dates` datetime DEFAULT NULL,
  `kt_domainnameshop_contents` text,
  `kt_domainnameshop_titles` varchar(100) DEFAULT NULL,
  `kt_domainnameshop_url_photos` varchar(100) DEFAULT NULL,
  `kt_domainnameshop_url_links` varchar(100) DEFAULT NULL,
  `kt_domainnameshop_url_githubs` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`kt_domainnameshop_ids`),
  UNIQUE KEY `kt_domainnameshop_ids` (`kt_domainnameshop_ids`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;

-- --------------------------------------------------------

--
-- 表的结构 `k_prose`
--

CREATE TABLE IF NOT EXISTS `k_prose` (
  `kt_prose_ids` int(20) NOT NULL AUTO_INCREMENT,
  `kt_prose_dates` datetime DEFAULT NULL,
  `kt_prose_contents` text,
  `kt_prose_titles` varchar(100) DEFAULT NULL,
  `kt_prose_url_thinks` varchar(100) DEFAULT NULL,
  `kt_prose_url_links` varchar(100) DEFAULT NULL,
  `kt_prose_url_githubs` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`kt_prose_ids`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=125 ;

--
-- 转存表中的数据 `k_prose`
--

INSERT INTO `k_prose` (`kt_prose_ids`, `kt_prose_dates`, `kt_prose_contents`, `kt_prose_titles`, `kt_prose_url_thinks`, `kt_prose_url_links`, `kt_prose_url_githubs`) VALUES
(100, '2014-02-20 15:20:46', '写日志就像挖坑一样，挖好了坑然后再随着时间慢慢填，直到最后把自己埋葬在故去的岁月。', '2014年的几个失败', '2', '2', '2'),
(101, '2013-08-17 09:40:10', '<p>所谓生意不过是经营人生，<br />\n<br />\n脚踏实地的做好眼下最需要做好的事情，才会是人生真正的赢家。</p>', '笨小狼生意经', '3', '3', '3'),
(102, '2013-02-16 09:37:25', '回忆。。。是一杯苦苦的浓茶', '回忆', '５', '５', '５'),
(103, '2011-11-12 09:37:25', '有的时候就是这样，不一定是哪里做的不好，只是没有缘份，所以没有结局，注定成为心中，不想提起的过去，只是放不下，一直放不下，喜欢的人可以很多，春去秋来，身边的人一个又一个的走过，这才发现，我已经大了，看着十几岁的小孩，跟着他们一起装幼稚，直到某一天看着镜子才发现，里面的我，有着说不出的狼狈，几个人，一些事，系着一生，斩不断，放不下，默默祝福，静静守护…', '这样的心情，你有木有？', '５', '５', '５'),
(104, '2011-08-31 10:48:28', '九几年的肇东, 路边有花坛有植树, 甬道上也有着一直延伸到另一边的盲道, 二零一一年了, 时光变迁, 岁月无言, 说不出城规划是对是错, 多了闪闪的路灯, 扩宽了许多的坦道, 也缺少了那绿意葱葱的宁静清闲, 这也许是回忆, 这也只能是回忆, 灯红不过一时的繁华, 青石板的甬路是今年新修建的, 夜晚在灯光下一闪波澜, 却永远失去了那已成回忆的盲路的寓意, 不经意的举起又不经意间的放下, 过往如烟, 烟若散去, 九几年的肇东, 九几年的旧花坛与旧盲路....', '九几年的肇东', '1', '1', '1'),
(105, '2011-08-10 07:32:29', '在家安心的早睡 ，多读一些好书 ，避免接触到一些人 ，可以少掉许多烦心事 ，还可以听听歌 ，练练字 ，有事时找找朋友打打羽毛球，没事时拿起刻刀玩玩木雕 ，时间充沛的话还可以去看看绘画 ，有点憧憬了啊。。', '筹划一下暑假做什么吧', '５', '５', '５'),
(106, '2011-05-17 19:26:33', '我想放假..', '我想放假。。', '５', '５', '５'),
(107, '2011-04-13 07:20:29', '<p>清凉的秋风吹落了一地的红叶，随着脚步踩碎的不只是干枯的叶子，还有我们不愿回旋的记忆。</p>\r\n\r\n<p>也许，我会去感伤岁月的无情，用一根根看不见的绳索牵长了我们的身影，也牵白了我们的双鬓一缕、发髻一丝。光阴流逝，不复童邪。</p>\r\n\r\n<p>命运的脚步就这样牵着我的双手，顺着它的足迹前行，一步步，回首时是辛酸甜美的万千童趣、细腻亲情，再回身已是千言万语，一切尽在不言中，也许，这就是成熟，流伤的岁月以此做结，把我们与回忆无情的割断，延着这根绳索，除去前方隐约的灯火，我们已经丢掉了来时的道路，无奈使我们只有顺着绳索，看着灯火。</p>\r\n<p>我们就这样走着，不知道前面的风是否凄冷，也不清楚会不会遇上彻骨的冰雨，延着这条看不见的绳索，我们万千人在彼此应当相遇的地方相遇，又在离散的时刻离散。</p>\r\n\r\n<p>时间与空间交错，彼时的离散又换得今时的相遇，只是顺着绳索回望，身后的明月早已换了轨迹，也许，我们需要彼此守护的不只是那根断了线又牵强连在一起的交错，我们还要在彼此共同走过的道路上做一个永远铭记的结，我们有着共同的理想并在同一片天地里携手挥散汗水而拼搏。</p>\r\n\r\n<p>前方的灯火隐隐地向我们发出邀请，周围如雾一般的岁月朦胧了无数根如网一般交错的绳索，而我们这些迷茫于亲情和爱情的人正如一颗颗延着自己的轨迹运行的恒星，美丽而凄凉。</p>\r\n\r\n<p>过去的都已过去，让我们一起挥手离别消散于时空的岁月，只留下淡淡痕迹告诉我们，此处的风景，我们来过，看过，拥有过也留恋过，而我们现在则要延着岁月这条看不见的绳索向更远更高处攀登，在那里我们将一起挑战我们的命运，向所有熟识我们的人用力挥起我们的臂膀，告诉他们我是最强者、</p>\r\n\r\n<p>只是想要告别却迟于告别，想要割断又难以割断。</p>\r\n\r\n<p>谁又能告诉我，怎样做才是真的正确，因为，我们彼此迷惑。。。。</p>\r\n', '看不见的绳索', '５', '５', '５'),
(108, '2010-12-02 09:36:24', '<p>当我们回首张望,看到的是一连串的挫折与辛苦,狼藉不堪的记忆与前所未有的羞辱,我们又会怎么做呢?<br />\r\n当脆弱的我们如同风浪中的一叶孤舟,柔软的心在平静了许久的岁月里终于不经重负被打破.我们,是要抱怨自己太过软弱还是铭记那颗石子所带来的伤痛?<br />\r\n或许忘记只会使我们的心更加的疼痛,因为我们的不够成熟与不够世故.<br />\r\n或许追忆更会使我们深深地陷入痛苦,因为我们的执著与我们的坚定.<br />\r\n乱如柳絮的是我们不知所云的唠叨与重复,因为我们不确定这一路航程,同行的船是否是真的愿意与我们同行.<br />\r\n当冷漠地风吹偏轨迹,平静无声的海面只留下了我们寂寞的依旧在重复着自己的惊慌失措.<br />\r\n时间慢慢走过,在夕阳里,我们是被遗弃的如同在黑暗中呜咽的小孩,一步步,渐行渐远...---</p>\r\n', '当我们回首张望', '５', '５', '５'),
(109, '2010-11-14 20:45:22', '<p>生活如一曲悠扬的歌，当最后一个音符飘然消于天地，我们的人生又将如何继续？<br />\n------------- 记&nbsp;<br />\n清晨的阳光洒下金色的丝线，柔和的风轻轻染在脸庞，春日里的冰雪缓缓融化，泥土里新生的草绿依然嫩白，忙于自己世界中的我们，是否忽略了眼角处的青春风景，而这，终究是一种损失还是一种收获？<br />\n&nbsp;<br />\n时光流逝，春雨潇潇，秋风瑟瑟，迎面的将不再是只有十一二岁的童忆，天真悄然落下，成熟一点点加长了我们的裤脚，转瞬间，昨昔隐约依旧，在那深藏的记忆里埋葬。<br />\n下一刻的我们又将去往哪里，是将旧时的陈积一起堆叠到一起，借着这些霉掉了地心情，静静地坐在一旁等待着上天的眷顾与怜悯，用发酸了的味道去博得一个又一个路过了的人的眼泪，只是，眼泪再多也聚不成深海。<br />\n&nbsp;<br />\n每天临行前的一盏淡茶，旅途归来时的一杯热水，还有深夜工作时的醒神的牛奶，或许生活只需要我们迈进一小步就可以得到它的恩赐。<br />\n有些时候我们精疲力尽的努力不过是为了麻痹自己，有些时候我们的偏执也只不过是为了那一丝的努力。<br />\n&nbsp;<br />\n人生旅途，下一刻，是谁又会在哪里？</p>\n\n<p>&nbsp;而我呢， 一定会在很远很远的地方...&nbsp;</p>\n', '下一分钟的你又在哪里', '４', '４', '４'),
(110, '2010-05-29 12:01:37', '<p>风尘绝，只把相思泪情牵<br />\n过往事，了如无悔恨不来<br />\n念何处，听雨今夜无眠<br />\n箫声断，嘶哑两眼云烟<br />\n错已错，一行刻字心上<br />\n乱已乱，一缕旧日难猜<br />\n一抹断肠天，只愿你永远笑美如颜</p>\n\n<p><br />\n------------作于2010年5月29日难忘的雨天-------小坏 &#39;&nbsp;kang ------------</p>\n', '笑美如颜', '５', '５', '５'),
(111, '2009-07-02 21:51:17', '<p>上天把你送到我面前&nbsp;<br />\r\n我祈祷&nbsp;<br />\r\n在可能相见的最后一天&nbsp;<br />\r\n直到你真的出现&nbsp;<br />\r\n我不知所措&nbsp;<br />\r\n所有的话都埋藏&nbsp;<br />\r\n几句简单的问候&nbsp;<br />\r\n彼此都带着失望离散&nbsp;<br />\r\n把握&nbsp;<br />\r\n当所想的真实出现&nbsp;<br />\r\n又有谁可以完美的对待&nbsp;<br />\r\n彼此失望湮灭想念&nbsp;<br />\r\n也许从此不再&nbsp;<br />\r\n牵挂与惦记依然是记忆深处的留念&nbsp;<br />\r\n也许还会可以&nbsp;<br />\r\n却不知道下一次会在哪里相遇&nbsp;<br />\r\n而等待永远是最残酷的期盼&nbsp;<br />\r\n<br />\r\n---------------2009年.初夏--kang-------------</p>\r\n', '命运的捉弄', '５', '５', '５'),
(112, '2009-03-19 10:32:27', '<p>清晨的雾气还没有散去，天却以清明，新鲜的空气中弥漫着潮湿的味道，风又吹着你满身干爽，有些事就是这样矛盾，就如同我骑着车子从某条小道穿过，看见了路旁树上纷纷飘下的叶子，而自己却明明在昨天遇见过它们---在树枝上随着风摇摇摆摆并且是一身的绿色。</p>\r\n\r\n<p>虽然一地的黄叶就铺在我的脚下，我却仍在诧异秋天来的迅急，不过才朝夕间世界竟换了一个颜色，以至从前那深沉、晶莹的绿还在我的眼底留着影子。我好奇夏天是什么时候悄然遁去，而秋天又是什么时候悄然而来隐藏在昨晚明朗的月光下，然后在我们对视觉放松警惕时又忽然出现使我们对它措手不及。</p>\r\n\r\n<p>或许是因为秋风前些天在忙着吹熟麦子而忘了这里；或许是因为秋日一直在催落果子而无暇顾及；更或许秋天有意这样安排好捉弄我们这些早已对时间失去概念的人。我，好奇，好奇自己什么时候开始忘记了日历；我，好奇，好奇自己什么时候开始只记得这座城市里的这一段道路；不过，我更好奇从小就爱观察的自己从什么时候起竟只知道下雨是春绿色夏落叶是秋白雪是冬。</p>\r\n\r\n<p>时间在举足间流逝，随着越来越凝重的空气由万木的苏醒到大地的沉睡，其间经历多少又失去了多少，人也许不再愚昧，但不见得会从此高尚。自然在变，其间的种种缤纷色彩，你不经历过永远也想象不到它的美丽。我好奇，为什么儿时的记忆始终印在我的脑海里，是因为那里有花中飞舞的蝴蝶和懒散的蜗牛吗？</p>\r\n\r\n<p>一路走过去又一路走回来，空中飘起了雨丝，柳枝在风中摇摆，我边走边听这难得的宁静，月光渐渐从云头洒下，星星也探出头脚，此时人家的灯光早已熄灭，这一路的孤寂怕只有自己才懂，朝不见旭日，晚不见夕阳，一路陪着星星伴着月亮，慢慢地在路上。</p>\r\n\r\n<p>也许有一天，我会不再好奇，因为我已做了秋天飘落的叶子，等待我的将是重归尘土。我的疑惑就写在黄叶铺成的路上吧，好让后来的人知道珍惜自己眼中的生活。。。</p>\r\n', '我们的好奇', '５', '５', '５'),
(113, '2008-08-16 06:35:24', '<p>沧海淹没了悲的尘埃<br />\n海鸟从何处飞来<br />\n衔走的是谁的青丝<br />\n将它投身大海<br />\n当一缕月光洒在波浪<br />\n是星星人间天上<br />\n鲛女的泪珠连成线<br />\n打断了记忆永恒时光<br />\n是谁把自己抛弃<br />\n看不见红颜老去<br />\n一株相思树上花儿等几时开<br />\n唤来的烟雨朦胧了眼泪<br />\n古老传说的缘<br />\n刻画在海底神秘的石板岩<br />\n当第一颗夜明珠照亮了石版画<br />\n悄悄写入轮回的<br />\n又是谁的青春与命运</p>\n', '沧海淹没了悲的尘埃 ', '５', '５', '５'),
(114, '2008-10-24 10:30:29', '<p>树梢的月亮映着红颜<br />\n你一笑让我像在梦间<br />\n从相识到相恋<br />\n什么阻隔都不算难<br />\n只有永远记得昨天<br />\n忘却了永恒的誓言<br />\n让快乐布满你憔悴的脸<br />\n就算让我死也无怨<br />\n只有永远记得昨天</p>\n\n<p>星空下一转眼一万年<br />\n当沧海变成桑田<br />\n我依然留着对你的恋<br />\n当风儿吹醒了尘埃的悲<br />\n当阳光洒在山上三生石边<br />\n一切都是那么美好天气不再多变</p>\n\n<p>星空下一转眼一万年<br />\n一万年里我化作顽石<br />\n陪着你的泪水发酸</p>\n', '转眼（歌词）', '５', '５', '５'),
(115, '2008-05-17 19:26:33', '<p>陶瓷瓶里的花儿谢<br />\r\n花瓣飘飘落在凌乱的酒杯<br />\r\n街头牵着你的双手坚持一起走<br />\r\n你洒下泪水说来世再做我的谁</p>\r\n\r\n<p>陶瓷瓶里的花儿谢<br />\r\n花瓣飘飘洒在桌上一封诀别信<br />\r\n漫漫人海中哪里寻到你<br />\r\n茫茫命里滚滚红尘</p>\r\n\r\n<p>陶瓷瓶里的花儿谢<br />\r\n花瓣飘飘落在凌乱的酒杯<br />\r\n街头牵着你的双手坚持一起走<br />\r\n你洒下泪水说来世再做我的谁<br />\r\n--------------</p>\r\n', '桃花尽（歌词）', '５', '５', '５'),
(116, '2008-02-16 09:37:25', '<p>美丽的天鹅湖畔<br />\r\n独角兽悠闲的睡起一片蜃景<br />\r\n身穿节白色裙子的善良女孩<br />\r\n悄悄的取走他的梦<br />\r\n那是一个会闪烁的水晶球<br />\r\n里面是慢放的恬静森林<br />\r\n花之精灵们在优雅的跳着舞<br />\r\n那长着翅膀的女孩拖着她的长裙<br />\r\n独角兽的梦是轻灵的音乐<br />\r\n女孩与梦就这样静静的透过森林看着远方<br />\r\n静静地<br />\r\n只有精灵们会在她与她的身旁<br />\r\n----------------</p>\r\n', '独角兽的梦与女孩', '５', '５', '５'),
(117, '2007-02-16 09:37:25', '<p>往事逾千年<br />\r\n曾经的白狐已成仙<br />\r\n凄清幽美的深山<br />\r\n凄清的岁月在孤独修炼<br />\r\n偶尔想起人间事<br />\r\n已作古的记忆中他的背叛<br />\r\n心在滴血因为迷途的爱情茫然<br />\r\n当年我成全了走出命运的你<br />\r\n可是又有谁还牵挂昔日的愉欢<br />\r\n跳一支舞吧<br />\r\n曾经千年<br />\r\n誓言将最美的旋姿留在心间<br />\r\n世上不再那优美的幻舞<br />\r\n只有我意想的梦园<br />\r\n往事逾千年<br />\r\n曾经的白狐已成仙<br />\r\n凄清幽美的深山<br />\r\n凄清的岁月在孤独修炼<br />\r\n偶尔梦中记得人间</p>\r\n', '仙狐（歌词白狐续）', '５', '５', '５'),
(118, '2007-02-16 09:37:25', '<p>希望你是一株小草<br />\r\n青青的<br />\r\n成长不会寂寞<br />\r\n我是一方沃土<br />\r\n陪你枯老<br />\r\n&nbsp;<br />\r\n不要畏惧风雨<br />\r\n那不过是生命的试炼<br />\r\n他若到来<br />\r\n请紧紧抓牢我<br />\r\n我将随你同看雨后的彩虹<br />\r\n&nbsp;<br />\r\n彩虹沉淀着昨日的梦<br />\r\n梦中有经历的艰辛<br />\r\n艰辛时的憧憬<br />\r\n憧憬是万里晴空<br />\r\n晴空、暖风与清澈的泉<br />\r\n&nbsp;<br />\r\n那清泉的水洗礼<br />\r\n朦胧的心不再挣扎<br />\r\n我愿付出我的土壤<br />\r\n无私地给予<br />\r\n陶醉在温馨里<br />\r\n&nbsp;<br />\r\n希望你是一株小草<br />\r\n青青的<br />\r\n成长不会顾虑<br />\r\n我是一方沃土<br />\r\n陪你欢笑</p>\r\n', '希望你是一株小草', '５', '５', '５'),
(119, '2006-06-05 17:19:12', '<p>青草香，<br />\n花依旧，<br />\n过眼事如烟，<br />\n只有人如故。</p>\n\n<p>漫蝶飞，<br />\n七彩木，<br />\n怎见鹊桥边，<br />\n牛郎织女遇。</p>\n\n<p>瓜藤下，<br />\n细雨绵，<br />\n几昼夜无眠，<br />\n挂念心肠穿。<br />\n&nbsp;<br />\n思绪飞，<br />\n盼祈愿，<br />\n两人依两人伴，<br />\n水月镜花梦里缘 ...</p>\n', '青草香', '５', '５', '５'),
(120, '2006-02-16 09:37:25', '<p>那种了千年的记忆<br />\r\n我盼它花开<br />\r\n随缘海里的狼<br />\r\n在永恒的等待...<br />\r\n相思树上美艳早已盛开</p>\r\n', '那种了千年的记忆', '５', '５', '５'),
(121, '2006-02-16 09:37:25', '<p>风中的飞尘，<br />\r\n断想它的梦，<br />\r\n梦中是桃园仙境：<br />\r\n女织男耕，<br />\r\n老怡童庆，<br />\r\n没有烽燧的硝烟，<br />\r\n没有勾心斗角的残破心灵</p>\r\n\r\n<p>风中的飞尘，<br />\r\n不甘微小而被遗忘，<br />\r\n经历太多的人事：<br />\r\n奸佞、忠义或是真情至死不渝。<br />\r\n飞尘不禁辛酸，<br />\r\n泪水飘洒尘世，<br />\r\n又有谁知道<br />\r\n天降的雨<br />\r\n是飞尘的哭泣！</p>\r\n\r\n<p>风中的飞尘<br />\r\n没有可寻的踪迹，<br />\r\n无从知晓起始，<br />\r\n无法预知终极，<br />\r\n漫无目的<br />\r\n注定孤独今世</p>\r\n', '飘尘', '５', '５', '５'),
(122, '2005-03-22 19:26:33', '<p>姮娥<br />\n你这远古的传奇<br />\n是否还依稀记得<br />\n你腾起的形景？<br />\n妩媚的身影随风而起<br />\n清寒的星光撒满天际<br />\n却唯独你<br />\n身上只留月的迷离<br />\n听，<br />\n你身后哀叹的<br />\n是迷茫的后弈，<br />\n他在思考什么?<br />\n如何接受心爱的人背叛离去？<br />\n可憎的仙宫！可憎的天地！<br />\n看<br />\n姮娥，<br />\n你的爱郎，<br />\n正在拔起射日的神箭<br />\n架在弓弦上能听到凤凰的欢啼<br />\n显得无限神秘。<br />\n电光在箭尖聚集，<br />\n仿佛要撕裂这黑暗的沉寂！<br />\n姮娥啊！<br />\n你是世间最美丽的女子，<br />\n拥有这人间王者（后弈）最真挚的情愫<br />\n你不该如此不禁诱惑，<br />\n惹怒那连太阳都惧怕的后弈！<br />\n你娇弱的身躯怎能抵挡<br />\n这开天辟地的神力？<br />\n姮娥，<br />\n你腾空而起，<br />\n飞的欢悦也渐渐被懊悔与恐慌代替，<br />\n怎样的敏捷灵活才能避开这箭铓的恐怖！<br />\n终于<br />\n在泪水中，<br />\n那携着火焰的精灵扑向你！<br />\n姮娥啊，<br />\n怎样的幻想也无法抹掉现实，<br />\n那萧萧的箭声已传到耳际，<br />\n耀眼绚丽的电光甚至触摸到了你的裙裾！<br />\n不知所措的你可知<br />\n他是因为太爱你才痛下杀意！<br />\n&nbsp;<br />\n你绝望，你悔恨，你伤心！<br />\n你闭上了眼<br />\n等待生命被燃烧枯竭的一瞬，<br />\n感受死的气息却仍徘徊在生的边际<br />\n仿佛世间静止，<br />\n让那箭的锋芒刺破你的肌肤，<br />\n却无法再进一步穿透你的心！<br />\n这一瞬简直就是一世！<br />\n你甚至感到自己华容已逝，伛偻蹒跚！<br />\n可当你睁开了眼，<br />\n却仍是随身的罗裙迎风而舞，<br />\n窈窕的身子婀娜多姿！<br />\n那箭呢？<br />\n你回身张望<br />\n满眼的却是漫天的流星！<br />\n姮娥啊，<br />\n看看你的脚下，<br />\n是天上人间最荒凉的地方！<br />\n一座广寒宫里带着无尽的忧郁与凄凉！<br />\n姮娥啊，<br />\n你的宿命便在这里，<br />\n注定一生孤独的你，<br />\n虽然莫名其妙的挣脱了玉殒香消得命运，<br />\n却无法离开这里去探寻外面的星辰<br />\n天上的星是无数的仙宫<br />\n可姮娥啊！<br />\n你不会不知道那在天际飞舞的流星，<br />\n正带着邃古后弈的使命<br />\n追踪你的足迹！</p>\n\n<p>&nbsp;</p>\n', '姮娥奔月（歌剧）', '５', '５', '５'),
(123, '2005-02-16 09:37:25', '<p>无形的风<br />\r\n最爱流浪<br />\r\n柔和的天空<br />\r\n是风之天堂<br />\r\n潮湿的空气里<br />\r\n杂着稻草香<br />\r\n秋日的思绪<br />\r\n会染黄整片麦浪<br />\r\n收获的喜悦<br />\r\n由谁传递 ？<br />\r\n清晨的镜泊<br />\r\n又是谁在湖心飘荡 ？</p>\r\n', '风', '５', '５', '５'),
(124, '2005-02-16 00:00:00', '<p>清风吹过，<br />\r\n稻草也要芬芳，<br />\r\n平凡而不被遗忘<br />\r\n是灵魂的清香！<br />\r\n午夜归来的雨<br />\r\n淋湿了月亮，<br />\r\n明日的天空<br />\r\n必定布满暖阳，<br />\r\n是爱的种子<br />\r\n种出一片爱的天堂</p>\r\n', '爱的天堂', '５', '５', '５');

-- --------------------------------------------------------

--
-- 表的结构 `k_riqi`
--

CREATE TABLE IF NOT EXISTS `k_riqi` (
  `kt_riqi_ids` int(20) NOT NULL AUTO_INCREMENT,
  `kt_riqi_dates` varchar(50) DEFAULT NULL,
  `kt_blogs_ids` int(20) NOT NULL,
  `kt_riqi_suijishu` varchar(100) NOT NULL,
  PRIMARY KEY (`kt_riqi_ids`),
  UNIQUE KEY `kt_riqi_ids` (`kt_riqi_ids`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=39 ;

--
-- 转存表中的数据 `k_riqi`
--

INSERT INTO `k_riqi` (`kt_riqi_ids`, `kt_riqi_dates`, `kt_blogs_ids`, `kt_riqi_suijishu`) VALUES
(26, ' Aug.2014 ', 50, ' 92101368745 '),
(27, ' Jul.2014 ', 51, ' 92101368745 '),
(28, ' May.2014 ', 52, ' 92101368745 '),
(29, ' May.2014 ', 53, ' 92101368745 '),
(30, ' May.2014 ', 54, ' 92101368745 '),
(31, ' May.2014 ', 55, ' 92101368745 '),
(32, ' May.2014 ', 56, ' 92101368745 '),
(33, ' May.2014 ', 57, ' 92101368745 '),
(34, ' May.2014 ', 58, ' 92101368745 '),
(35, ' Jan.2014', 59, ' 10693521874 '),
(36, ' Oct.2014 ', 60, ' 62537108419 '),
(37, ' Apr.2014 ', 61, ' 62537108419 '),
(38, ' Aug.2014 ', 62, ' 36578910142 ');

-- --------------------------------------------------------

--
-- 表的结构 `k_tags`
--

CREATE TABLE IF NOT EXISTS `k_tags` (
  `kt_tags_ids` int(20) NOT NULL AUTO_INCREMENT,
  `kt_tags_name` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`kt_tags_ids`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=13 ;

--
-- 转存表中的数据 `k_tags`
--

INSERT INTO `k_tags` (`kt_tags_ids`, `kt_tags_name`) VALUES
(9, '前端知识点'),
(10, 'grunt'),
(11, 'node.js'),
(12, '数据结构');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
